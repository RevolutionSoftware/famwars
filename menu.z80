;;; menu.z80
menu_txt:
.dw $0505				; x and y coordinates of menu
.db 4					; width of menu (in bytes: sets of 8 pixels)
.db 3					; # of menu options
.db "Option 1", 0
.db "Option 2", 0
.db "Option 3", 0

menuOptions:
.db 0
selected:
.db 0
menuCursorX:
.db 0
menuCursorY:
.db 0

cursor_sprite:
.db %00100000
.db %00110000
.db %00111000
.db %00110000
.db %00100000

; Run when user presses 2nd on the map
loadMenu:
	ld bc, (cursorX)	 ; c = x, b = y
	call getTile
; hl points to tile position
	ld a, (hl)
; ... decide which menu to draw based on tile id / if a player has been selected
	ld hl, menu_txt
	ld e, (hl)			; x coord
	inc hl
	ld d, (hl)			; y coord
	inc hl
	ld c, (hl)			; width
	inc hl
	ld a, (hl)			; height
	add a, a			; x2
	add a, (hl)			; x3
	add a, a			; x6
	inc a				; add an extra space underneath the text
	ld b, a				; bc = $WWHH
drawMenu:
	push de				; de = x/y coords of menu, we need to calculate text position
	push hl				; hl = pointer to start of text data
		call drawRectangle
	pop hl
	pop de
	ld b,(hl)			; # menu options
	ld a,b			  ; save number of menu options
	ld (menuOptions),a  ; .. so we can use it in the cursor routine
	inc hl				; start of text data
	inc d			   ; + 1 jump past the top of the rectangle
	ld a,e
	add a,a
	add a,a
	add a,a				 ; x position was byte-aligned, so we must *8
	ld e,a
	inc d
	ld (menuCursorX),de	 ; save cursor x and y values
	dec d
	add a,6				 ; shift text 6 pixels to the right (don't draw over top of box border)
	ld e,a
drawMenu_loop:
	push bc
	push de
		ld (penCol),de
		bcall(_VPutS)
	pop de
	pop bc
	ld a,d
	add a,6
	ld d,a
	djnz drawMenu_loop

	call releaseKeys

	xor a
	ld (selected),a		; reset cursor to first menu item (position 0)
menuCursor:
	call drawMenuCursor	; draw sprite
	call ionFastCopy
	call drawMenuCursor	; erase sprite

; check if a key was pressed to quit the menu
    ld a,group5
    call getKey
    rla
     jr nc,quitMenu

    ld a,group1
    call getKey
    cp diClear
     jr z,quitMenu

    ld a,group6
    call getKey
    cp di2nd
    ld a,(selected)
     jp z,releaseKeys

	ld hl,menuCursor	; put menuCursor on the stack
	push hl				; .. ret will jump to menuCursor

; check keys
	ld b,7				; the delay's mask, must be all 1's: %1, %11, %111, %111, etc.
	call slowArrows		; returns c if the delay isn't finished [famwars.z80]
	 ret c

	ld hl,selected
	rra					; check for down
	 jr nc,menuCursorDown   ; if the bit is reset, down was pressed
	bit 2,a
	 jr z,menuCursorUp  ; normally up is the third bit, but here it's bit 2 because of the rra
	ret

menuCursorUp:
; check if cursor is at position 0, if so can't continue
	ld a,(hl)
	or a
	 ret z
	dec (hl)			; decreasing selected moves the cursor up
	ret
menuCursorDown:
; check if menuOptions-1 = selected
	ld a,(menuOptions)	; menuOptions starts at 1, wherease selected starts at 0
	dec a				; .. so we need to subtract one
	cp (hl)				; hl points to selected
	 ret z
	inc (hl)			; increase selected moves cursor down
	ret

drawMenuCursor:
	ld a,(selected)	 ; currently selected option
	ld l,a
	add a,a			 ; x2
	add a,l			 ; x3
	add a,a			 ; x6
	ld hl,(menuCursorX)
	add a,h
	ld e,a
	ld a,l
	ld b,5
	ld ix,cursor_sprite
	jp drawSprite_var

quitMenu:
    scf
    jp releaseKeys

; Input:
; X = c, Y = b
; Output: tile in tilemap - hl
getTile:
	ld hl, (mapWidth)
	call multBL
	add hl, bc
	ld de, (mapPtr)
	add hl, de
	ret

; multiplies HL=B*L
multBL:
	ld e, l			; ld de,hl
	ld d, 0
	ld h, d			; clear out upper byte of HL
	ld l, d
_:
	add hl, de		 ; hl+de b times
	djnz -_
	ret

;######################
drawRectangle:
;# draws an outlined rectangle
;# input:
;#	- de = starting x/y (de = $YYXX)
;#	- bc = width (in bytes) and height (pixels): $HHWW
;######################
	ld a, e						; x
	ld l, d						; y
	push bc						; save width/height
		call getGbufOffset		; first find position in gbuf
	pop bc						; c = width, b = height of rectangle
	ld a, %01111111				; outer pattern (draw %01111111 on the left, %11111110 on right)
	ld e, $FF					; inner pattern: solid line
	call rectangleRow			; draw the top row	 
drawRectangleMiddle:
	ld a, %10000000				; %10000000 on left, %00000001 on right
	ld e, %00000000				; erase what's inside
	call rectangleRow			; draw the row
	djnz drawRectangleMiddle	; repeat rectangleHeight times
	ld a, %01111111				; now draw the bottom row
	ld e, $FF					; a solid line
;a = outer byte
;e = inner byte
rectangleRow:
	push bc
		ld (hl), a				; outer pattern into the address of hl
		inc hl					; next byte in gbuf
		ld b, c					; b = width
rectangleRow_loop:
		ld (hl), e				; store inner pattern ($FF or $00)
		inc hl					; next byte
		djnz rectangleRow_loop	; repeat
		rlca					; rotate outer byte (rotate left through carry accumulator)
		ld (hl), a				; save right side of rectangle
	pop bc						; restore width/height
	ld a, 11
	sub c						; c actually = width -1, since the first byte is drawn outside of the loop
	ld d, 0
	ld e, a
	add hl, de					; add offset to gbuf (next row)
	ret
